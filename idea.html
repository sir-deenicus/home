<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <!-- 
      The Recursively Building Features and Structure Learning
 parameters will be replaced with the 
      document title extracted from the <h1> element or
      file name, if there is no <h1> heading
    -->
    <title>Recursively Building Features and Structure Learning
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="http://code.jquery.com/jquery-1.8.0.js"></script>
    <script src="http://code.jquery.com/ui/1.8.23/jquery-ui.js"></script>
    <script src="http://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/js/bootstrap.min.js"></script>
    <link href="http://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/css/bootstrap-combined.min.css" rel="stylesheet">
    <link type="text/css" rel="stylesheet" href="style.css" />
    <script src="tips.js" type="text/javascript"></script>
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="container">
      <div class="row" style="margin-top:30px">
        <div class="span1"></div>
        <div class="span10" id="main">
          <h1>Recursively Building Features and Structure Learning</h1>

<h2>Introduction</h2>

<p>One quickly learns that when solving data problems or building models that most of one's time is spent thinking up features, organizing data, choice of algorithm and fiddling with parameters. The actual implementation of the algorithm (if one even does this) is relatively minor.</p>

<p>Yet most of this work is dull, mechanical and not particularly complicated. Just the kind of thing ideal for automation. Instead of painstakingly sifting out features, wouldn't it be ideal if you could specify some basic functions built from a set of universal data operators and have the program search within the subset you specify? The search space would be much improved because of the high level functions you construct, encoding a lot of prior information and structure.</p>

<p>In addition to searching for features it would be useful if this method could match features to particular classifiers and what's more pick out the parameters and structure of a classifier (structures as in things other than just parameters - for example what type of distance function or kernel to use or what type of distribution to build upon).</p>

<h2>The Ideas</h2>

<p>This is not a learning algorithm (well it is, just not in the sense most people think of the word) but an annealing search method trying different composition of operators to build a final structure. The operators on data sets are the following:</p>

<h3>Feature Selection Methods:</h3>

<ul>
<li><p>None.</p></li>
<li><p>The <code>Subspace: 'a [] -&gt; int []</code> method. This simply takes a vector and returns a list of indices displaying the selected indices.</p></li>
<li><p><code>Aggregation : 'a [] [] -&gt; int * int-&gt; int-&gt; int -&gt; Map&lt;'a, 'b []&gt; * 'a[]</code> takes a list of vectors, min and max index to look at, how many steps to look back, a filter index (-1 for none), and generates a map for use of online computation for the default operators of mode, median, mean, max, min and mean. This makes looking back N steps more efficient and is a type of memoization. Median and mode use (value, count) so the Map is not of type 'a always. Custom aggregators are also possible. This of course, only makes sense for draws that are not independently distributed.</p></li>
</ul>

<p>After aggregation selecting a subspace is an option and the result is concatenated to form a feature vector. As iterations occur, each feature is scaled using weighted majority and sampled based on the weight. Over time the best features are selected for the classifier.</p>

<h2>Search Grammars</h2>

<p>Algebraic Types are great to build trees with but are not very extensible. Combining Active Patterns and objects allows some of that power but at the cost of some cumbersome syntax - well worth the price.</p>

<p>Suppose I have a decision tree that I wish to classify with. I have different options like whether to have it use variance or entropy and various parameters on how to build it. To search automatically, I need to form a language and grammar that will tell how to search across this space.</p>

<p>The default Expression class is as below.</p>

<pre class="fssnip">
<span class="l"> 1: </span><span class="k">type</span> <span onmouseout="hideTip(event, 'fs1', 1)" onmouseover="showTip(event, 'fs1', 1)" class="i">Expr</span>() <span class="o">=</span> <span class="k">class</span> <span class="k">end</span>
<span class="l"> 2: </span><span class="k">type</span> <span onmouseout="hideTip(event, 'fs2', 2)" onmouseover="showTip(event, 'fs2', 2)" class="i">BinExpr</span>(<span class="i">_e1</span><span class="o">:</span><span onmouseout="hideTip(event, 'fs1', 3)" onmouseover="showTip(event, 'fs1', 3)" class="i">Expr</span>, <span class="i">_e2</span><span class="o">:</span><span onmouseout="hideTip(event, 'fs1', 4)" onmouseover="showTip(event, 'fs1', 4)" class="i">Expr</span>) <span class="o">=</span> <span class="k">inherit</span> <span onmouseout="hideTip(event, 'fs1', 5)" onmouseover="showTip(event, 'fs1', 5)" class="i">Expr</span>()
<span class="l"> 3: </span>                      <span class="k">member</span> <span class="i">x</span><span class="o">.</span><span class="i">bex</span> <span class="o">=</span> <span class="i">_e1</span> , <span class="i">_e2</span>
<span class="l"> 4: </span>
<span class="l"> 5: </span><span class="k">type</span> <span class="i">Add</span>(<span class="i">_e1</span><span class="o">:</span><span onmouseout="hideTip(event, 'fs1', 6)" onmouseover="showTip(event, 'fs1', 6)" class="i">Expr</span>, <span class="i">_e2</span><span class="o">:</span><span onmouseout="hideTip(event, 'fs1', 7)" onmouseover="showTip(event, 'fs1', 7)" class="i">Expr</span>) <span class="o">=</span> <span class="k">inherit</span> <span onmouseout="hideTip(event, 'fs2', 8)" onmouseover="showTip(event, 'fs2', 8)" class="i">BinExpr</span>(<span class="i">_e1</span>,<span class="i">_e2</span>) 
<span class="l"> 6: </span>             <span class="k">type</span> <span class="o">&#39;</span><span class="i">a</span> <span class="i">Vector</span>(<span class="i">vals</span><span class="o">:</span> <span class="o">&#39;</span><span class="i">a</span> []) <span class="o">=</span> <span class="k">inherit</span> <span onmouseout="hideTip(event, 'fs1', 9)" onmouseover="showTip(event, 'fs1', 9)" class="i">Expr</span>() <span class="k">member</span> <span class="i">x</span><span class="o">.</span><span class="i">vect</span> <span class="o">=</span> <span class="i">vals</span>
<span class="l"> 7: </span><span class="k">type</span> <span class="i">Val</span>(<span class="i">num</span><span class="o">:</span><span onmouseout="hideTip(event, 'fs3', 10)" onmouseover="showTip(event, 'fs3', 10)" class="i">float</span>) <span class="o">=</span> <span class="k">inherit</span> <span onmouseout="hideTip(event, 'fs1', 11)" onmouseover="showTip(event, 'fs1', 11)" class="i">Expr</span>() 
<span class="l"> 8: </span>    <span class="k">member</span> <span class="i">x</span><span class="o">.</span><span class="i">e1</span> <span class="o">=</span> <span class="i">num</span>
<span class="l"> 9: </span>
<span class="l">10: </span><span class="k">let</span> (|<span class="i">Add</span>|_|) (<span class="i">x</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fs1', 12)" onmouseover="showTip(event, 'fs1', 12)" class="i">Expr</span>) <span class="o">=</span> <span class="k">match</span> <span class="i">x</span> <span class="k">with</span> <span class="o">:?</span> <span class="i">Add</span> <span class="k">as</span> <span class="i">add</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs4', 13)" onmouseover="showTip(event, 'fs4', 13)" class="i">Some</span>(<span class="i">add</span><span class="o">.</span><span class="i">bex</span>) | _ <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs5', 14)" onmouseover="showTip(event, 'fs5', 14)" class="i">None</span>
<span class="l">11: </span><span class="k">let</span> (|<span class="i">Float</span>|_|) (<span class="i">x</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fs1', 15)" onmouseover="showTip(event, 'fs1', 15)" class="i">Expr</span>) <span class="o">=</span> <span class="k">match</span> <span class="i">x</span> <span class="k">with</span> <span class="o">:?</span> <span class="i">Val</span> <span class="k">as</span> <span class="i">value</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs4', 16)" onmouseover="showTip(event, 'fs4', 16)" class="i">Some</span>(<span class="i">value</span><span class="o">.</span><span class="i">e1</span>) | _ <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs5', 17)" onmouseover="showTip(event, 'fs5', 17)" class="i">None</span>
<span class="l">12: </span>            <span class="k">let</span> (|<span class="i">Vector</span>|_|) (<span class="i">x</span> <span class="o">:</span> <span onmouseout="hideTip(event, 'fs1', 18)" onmouseover="showTip(event, 'fs1', 18)" class="i">Expr</span>) <span class="o">=</span> <span class="k">match</span> <span class="i">x</span> <span class="k">with</span> <span class="o">:?</span> <span class="i">Vector</span> <span class="k">as</span> <span class="i">value</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs4', 19)" onmouseover="showTip(event, 'fs4', 19)" class="i">Some</span>(<span class="i">value</span><span class="o">.</span><span class="i">vals</span>) | _ <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs5', 20)" onmouseover="showTip(event, 'fs5', 20)" class="i">None</span></pre>


<p>As is that is not very useful. The key idea is of composable search grammars. The basic combinators are called pertubators. The default ones are perturbations on 'a [] and float and resampling.</p>

<pre class="fssnip">
<span class="l"> 1: </span><span class="k">type</span> <span onmouseout="hideTip(event, 'fs6', 21)" onmouseover="showTip(event, 'fs6', 21)" class="i">System</span><span class="o">.</span><span onmouseout="hideTip(event, 'fs7', 22)" onmouseover="showTip(event, 'fs7', 22)" class="i">Random</span> <span class="k">with</span>
<span class="l"> 2: </span>   <span class="k">member</span> <span class="i">t</span><span class="o">.</span><span class="i">NextDouble</span>(<span class="i">step</span>) <span class="o">=</span>  <span class="i">t</span><span class="o">.</span><span class="i">NextDouble</span>() <span class="o">*</span> (<span class="i">step</span>) <span class="o">-</span> (<span class="i">step</span><span class="o">/</span><span class="n">2.</span>) 
<span class="l"> 3: </span>
<span class="l"> 4: </span><span class="i">perturbFloat</span> <span class="i">x</span> <span class="i">minim</span> <span class="i">maxim</span> <span class="i">step</span> <span class="o">=</span>   
<span class="l"> 5: </span>   <span onmouseout="hideTip(event, 'fs8', 23)" onmouseover="showTip(event, 'fs8', 23)" class="i">min</span> <span class="i">maxim</span> (<span onmouseout="hideTip(event, 'fs9', 24)" onmouseover="showTip(event, 'fs9', 24)" class="i">max</span> (<span class="i">x</span> <span class="o">+</span> <span class="i">r</span><span class="o">.</span><span class="i">NextDouble</span>(<span class="i">step</span>)) <span class="i">minim</span>)
<span class="l"> 6: </span>
<span class="l"> 7: </span><span class="i">perturbFloats</span> <span class="i">xs</span> <span class="o">=</span>
<span class="l"> 8: </span>   <span class="k">let</span> <span class="i">index</span> <span class="o">=</span><span class="i">r</span><span class="o">.</span><span class="i">Next</span>(<span class="n">0</span>, <span class="i">xs</span><span class="o">.</span><span class="i">Length</span>)  
<span class="l"> 9: </span>   <span class="i">xs</span><span class="o">.</span>[<span class="i">index</span>] <span class="o">&lt;-</span> <span class="i">uncurry4</span>  (<span class="i">perturbxs</span><span class="o">.</span>[<span class="i">index</span>])
<span class="l">10: </span>
<span class="l">11: </span><span class="i">resample</span> <span class="i">len</span> <span class="i">items</span> <span class="o">=</span> [| <span class="k">for</span> <span class="i">i</span> <span class="k">in</span> <span class="n">1..</span><span class="i">len</span> <span class="k">-&gt;</span> <span class="i">items</span><span class="o">.</span>[<span class="i">r</span><span class="o">.</span><span class="i">Next</span>(<span class="n">0</span>,<span class="i">len</span>)]|]
<span class="l">12: </span>
<span class="l">13: </span><span class="k">let</span> <span class="k">rec</span> <span class="i">sevalfunc</span>  <span class="o">=</span> <span class="k">function</span> 
<span class="l">14: </span>  | <span class="i">Float</span> <span class="i">f</span> <span class="k">-&gt;</span> <span class="i">Float</span> (<span class="i">perturbFloat</span> <span class="i">f</span>)
<span class="l">15: </span>  | <span class="i">Vector</span> <span class="i">v</span> <span class="k">-&gt;</span> <span class="i">Vector</span> (<span class="i">perturb</span>
<span class="l">16: </span>  | <span class="i">e</span> <span class="k">-&gt;</span> <span class="i">evalfunc</span> <span class="i">e</span> </pre>


<p>The above combinators are useful across a broad class of search, able to represent different types of annealing algorithms. The added benefit is the extensibility of the system. Everything need not be defined ahead of time. Now for an interesting problem. Suppose we had some data and were deciding between random forest and boosted trees and the best way to construct the tree for each. First a method to search trees must be constructed and then a method to find the correctly size ensemble.</p>

<p>TreeExpr(variance:f : a -> b [], par1: float, par2 : float) = inherit Expr() member x.params = variance, par1, par2</p>

<p>match  e with 
   t(var , p1,p2) -></p>

          <div class="tip" id="fs1">Multiple items<br />type Expr =<br />&#160;&#160;new : unit -&gt; Expr<br /><br />Full name: idea.Expr<br /><br />--------------------<br />new : unit -&gt; Expr</div>
<div class="tip" id="fs2">Multiple items<br />type BinExpr =<br />&#160;&#160;inherit Expr<br />&#160;&#160;new : _e1:Expr * _e2:Expr -&gt; BinExpr<br /><br />Full name: idea.BinExpr<br /><br />--------------------<br />new : _e1:Expr * _e2:Expr -&gt; BinExpr</div>
<div class="tip" id="fs3">Multiple items<br />val float : value:&#39;T -&gt; float (requires member op_Explicit)<br /><br />Full name: Microsoft.FSharp.Core.Operators.float<br /><br />--------------------<br />type float = System.Double<br /><br />Full name: Microsoft.FSharp.Core.float<br /><br />--------------------<br />type float&lt;&#39;Measure&gt; = float<br /><br />Full name: Microsoft.FSharp.Core.float&lt;_&gt;</div>
<div class="tip" id="fs4">union case Option.Some: &#39;T -&gt; Option&lt;&#39;T&gt;</div>
<div class="tip" id="fs5">union case Option.None: Option&lt;&#39;T&gt;</div>
<div class="tip" id="fs6">namespace System</div>
<div class="tip" id="fs7">Multiple items<br />type Random =<br />&#160;&#160;new : unit -&gt; Random + 1 overload<br />&#160;&#160;member Next : unit -&gt; int + 2 overloads<br />&#160;&#160;member NextBytes : buffer:byte[] -&gt; unit<br />&#160;&#160;member NextDouble : unit -&gt; float<br /><br />Full name: System.Random<br /><br />--------------------<br />System.Random() : unit<br />System.Random(Seed: int) : unit</div>
<div class="tip" id="fs8">val min : e1:&#39;T -&gt; e2:&#39;T -&gt; &#39;T (requires comparison)<br /><br />Full name: Microsoft.FSharp.Core.Operators.min</div>
<div class="tip" id="fs9">val max : e1:&#39;T -&gt; e2:&#39;T -&gt; &#39;T (requires comparison)<br /><br />Full name: Microsoft.FSharp.Core.Operators.max</div>
          
        </div>
        <div class="span1"></div>
      </div>
    </div>
  </body>
  </html>